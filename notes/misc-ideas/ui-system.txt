i need to figure out just how complex i need to make the layout system. more specifically, I need to adapt the whole "relpos" thing, because it relied on anchors, and miniventure ui doesn't quite work like that.

actually. you know. maybe not. Who needs nested components? containers shouldn't have to be able to go in containers.

In minicraft plus, I had a system of menus, which held list items, and displays, which held menus. That's all I really need, right..?

hey maybe the key is menu placement..! I think I just positioned it around an anchor, like menu items...

...k, so it looks like I did all the positioning in the menu class; each menu in a display was independently positioned from the others. And lists were always top to bottom. I might keep that last bit. probably not though.

in miniventure, I'm going to have...
	
	- a chat screen, with dimensions relative to the screen size, and components laid out vertically with spacing and equal hori width.
	
	- a title screen with a list of buttons/labels, centered horizontally and vertically, with (varying?) spacing between elements.
	
	- help and credits screens, with widths relative to the screen size, and label height changing based on word wrapping.
	
	- game popups and menus with frames around them
	
	- item grids
	

will I ever need to have one menu be relative to another..? yes, crafting.

I think I'm going to have static sizing of elements, meaning none of this "preferred, min, max size" business. just the size, which is computed on call. I may cache it and use validation, but later, not initially now.

The question is, then: will I ever need components to fill available space, or otherwise make use of leftover space from other elements? if not, we're good...

...you know, if I did need that, I just got an idea: I could pass the available size in the getSize method. the first time, I pass 0,0. The second time, I pass the size that remains after adding all the elements. then I use that to decide how much space to actually give them.

That still doesn't actually help anything though because it doesn't solve the real problem here, which is that components need to be notified of their size. they shouldn't worry about that, just render in the space that they say they take up.

the one size that they know is the screen size.
hmm, so the chat screen labels will have to be told that they should take up half the screen width. Either that or have them fill the width of the menu. which I doubt I'll do.

if I *did* do the preferred/min/max size thing, then the max could be the entire screen when filling should happen. In the end, if there is less or more size than needed, layouts will make sure that all components get the same proportion of their max/min sizes. They should all be the same percentage of the way from the preferred to min/max sizes. this should be calculated in such a way that nothing breaks with those that have the same min/max size as the pref size.
the algorithm might go like this, per axis....
	- get the space remaining after getting all pref sizes
	- if negative, fetch min sizes. if positive, fetch max sizes. If 0, we're good and don't need to resize anything.
	- get difference between pref and fetched sizes
	- add up differences to get total difference. If 0, we can't resize anything so skip the next step (to avoid div by 0 error).
	- divide up remaining space according to the ratio of the size diff over the total size diff.
	- the above should work with both negative and positive space and size diffs.
	- set the component's dim value for that axis in the "actual size" cache.

add public "setWidth" and "setHeight" values for components. Layouts will use this to set the sizes, but this can also be used to set the size directly if there is no layout. same goes for setting the position.

LATER:
have calcPref/Min/Max size methods, that are protected, and actually calculate the size. getPref/Min/Max size methods will be public and final, and they will check if the cached value is null, and if so call the appropriate method to calculate it.
In addition to the cached sizes, there can be user-set sizes, which are checked in the getSize methods. if the corresponding user-set value is not null, then it is returned regardless of what the cache or calcSize method say. accessed with setPref/Min/Max size.
there will also be getPref/Min/Max Width/Height methods.

since these three are all the same, I think I'll put them in a class together. Size class.
they have cached width and height, and user-set width and height.
for methods they have getWidth, getHeight, and protected calcSize methods. also invalidate. and setWidth, setHeight, and setSize methods. maybe getSize.























Note: make sprites/ui folder.

Use RelPos like before, but treat menu items and menus similarly. That is, if you want to group items in a list, then you group them in a type of group, with a RelPos. These groups can also be grouped, each with a RelPos.

The only little issue here is keyboard focus. That actually shouldn't be an issue, though: the focus will start on the main group, and then you can choose a subgroup with the arrow keys, and you can press enter to select one. At that point, the keys traverse the subgroup's groups. Escape moves the focus out one. This progresses until you reach menu items, though technically it could progress further.

Any of these components could be made not focusable, in which case the focus selection will skip over them.

Within a given group, focus travels in a sensible direction; if horizontal, then left/right keys; if vertical, then up/down keys; if grid, then both.

The main thing I have to worry about, then, is making sure the user knows when something is out of focus.



Basic class structure / inheritance:

- Component extends Actor: selectable, relpos positioning, parent component, onselect, background rendering, size, input management

- Container extends Component - child components, layout of child components, hotkeys. Input used to select a child component. Note, if only one child component is selectable, then it is automatically selected. If no child components are selectable, then the container is not selectable either.

- Label extends Component - displays a string.
- Button extends Container - contains label, has onselect action. Has render state for pressed and not pressed.
- TextField extends Component - contains a field of text you can type in.
- OptionPicker extends Component - can select one of a list of options.

- Labeler extends Container - adds a label next to a component (takes a string, RelPos, and component; or default RelPos to LEFT).


Key presses: component can specify hotkeys that will activate them in the hierarchy when a child component has focus, and doesn't use the event


Component render method: has batch, configured to component pos offset if poss.
Also has alpha, to fade out components that are not active.
Outline will be drawn around currently selected component, unless the component specifies not to be outlined, in which case it will remain on the parent.

When a container is highlighted, all child components render at full opacity. It is only once the container is selected that the sibling components lose opacity.
If a container only has one selectable component, then the non-selectable sibling components should not lose opacity when the one is selected.



components:
	- text fields
	- labels
	- buttons
	- inventory
	- paragraphs



notes from feature todo list:

Improve UI system? Might scrap Scene2D. This also includes making a font for miniventure. And a background for menus and item lists. An options menu with music/sound volume and controls wouldn't be a bad idea. This will include an option to choose control style: keyboard only, or keyboard and mouse. The controls submenu will differ depending on this choice.
Another thing to consider here: integrated tutorial? Displays general controls on world start. Can disable tutorials in the options menu.
Note that the tutorial would not only consist of telling the controls, but it would also explain what to do to some degree. It would popup at key moments, triggered by trying to start a tile blueprint, or placing down furniture... It might just display a message over various entities/tiles though.
One last thing this ought to include: health bars for tiles. They show up when you deal damage, and stay for a second or so after you stop before disappearing.
Credits menu!