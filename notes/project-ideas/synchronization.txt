- server thread does most things, we just need to layout interactions with it
- entity changes can be immediate because the currently updating level, if any, will have cached the entity list on start of iteration
	- set does not even need to be synchronized since the same thread that would be modifying it is also the one that caches its value.

- remove use of separate server threads per client to make sync on known players unneeded, among other things

- however, note that many game server methods will be called from the server update thread.
	- These will often access the connection maps.
	- So, connection maps may have to be synchronized.
	- note that ONLY the game server thread will MODIFY the connection maps; however the the update thread will access them frequently.

- as yet unexplained:
	- most of the packet handling
	- knownPlayer management


client requests:
- connection
	- test for rejection due to single player world
	- note, I should actually reject anything that isn't the host in sp mode; no need to count connected players.
- disconnect
	- access player handle map ( SYNC POINT -> playerLock )
	- ignore if handle is null, else continue (internal)
	- stops validation timer (managed by same thread)
	- attempts to remove player from the game ( SYNC POINT -> ServerWorld.removePlayer() )
		- calls "removePlayer" in ServerWorld, perhaps passing PlayerData?
		- TODO explain removePlayer runtime layout below, and the rest of disconnect process
- log in
	- access connected player names to check for duplicates (managed by same thread)
	- access known players to check for existing data (managed by same thread)
	- creates a new server player, from data if existent (internal)
	- registers player into connection map ( SYNC POINT -> playerLock )
	- attempts to add player to a level ( SYNC POINT -> ServerWorld.loadLevel() )
		- calls "loadLevel" in ServerWorld with the player, player positioner, and level id
		- doesn't expect player to be in a level yet afterward
	- starts player entity validation timer (internal)
- level change
	- posts player level removal to ServerWorld player movement queue

Sync points:
- playerLock
	- locks access to the connection->playerData and player->connection maps
	- all access of these two maps must be within blocks synchronized with playerLock
- ServerWorld.loadLevel(player, positioner, levelid)
	- expects to be called from the game server thread, since only players can move levels
	- it'll either be a player login or level change that calls it, but both are the server thread
	- does not end with a loaded level; does not even do the level loading
	- adds the load request to a synced queue to be read by level initializer
	- load request is actually a lambda containing:
		- call to private form of loadLevel that takes only a level id, and returns a ServerLevel which was either loaded from file or fetched from the loadedLevels map
		- code to add player to the level
		- code to add the level to the loadedLevels map
- ServerWorld.removePlayer(player)
	- expects to be called from the game server thread, since only disconnects can cause players to be removed
	- this is the ONLY PLACE levels get removed/unloaded
	- will never be running loadLevel at the same time
	- sets a bit to signal that player should be removed

- ServerLevel.update(delta)
	- server update thread
	- 


server world level-related fields:
- synchronized map of id to level
	- accessed throughout most of the code
	- modified only by level initializer thread
- synchronized queue of entity actions
	- accessed at the end of an update frame in ServerWorld.update()
	- modified there, and also from game server thread to post 

- LevelCache no longer has two forms where one is a "non-generated level" and the other is a generated one
	- only contains data about the generated level
	- still includes island type since this will control a couple other things in game

world creation:
- when player presses "generate world" on client, server manager is called to generate the world and then start a server on it; it is passed a ProgressLogger to record its activity
- desktop launcher impl of ServerManager calls a static method in WorldGenerator, a class in the server module, to generate the world
	- world is generated level by level
	- each level is generated into a level cache (fairly simple to make a level cache from the tile set provided by IslandType), and then written to file, cache discarded
	- a WorldDataSet is returned for quick loading (though the entire world has also been written to file)
	- WorldDataSet does not contain detailed island data; it only notes the id of each of the levels that exist; levels are loaded back when a player connects
- ServerManager then calls its normal startServer method with the WorldDataSet...

initial world load i.e. startServer (which is incidentally called after world creation too):
- note, this takes place in the ServerWorld constructor...
- if world version is not current, then for each level:
	- level is loaded into a full ServerLevel, and then written back to file
	- done by:
		- calling private form of loadLevel as described above under "sync points" to get a ServerLevel object
			- normally called in the game server thread through the public loadLevel method
		- using level.save() to get a level cache
		- passing the level cache to a method in SaveLoadInterface which saves levels to file
- general world info is stored to class variables
- server is started



---- OLD ----


Requests for update thread processing, in order of precidence:
- 
- level loads
	- from level initializer thread; has a complete level to add to the set




- any entity level changes do not happen until end of frame
- any level registration changes do not happen until end of frame
- world saving does not occur until the end of the frame
	- new players are not registered until a world save
	- to register them, the players are fetched from the server during a save and each one is updated based on the info provided
	- saves happen at the absolute end of a frame
- player disconnects trigger an unloadPlayer in the world


instead of a generic "post runnable" method, the server has various actions which it will accept and postpone.
	- when an entity is added to or removed from a level
		- this is actually not even delayed to the end of the frame
		- it is delayed until a level finishes updating its entities and tiles, after which it will go through and add/remove entities as needed from its list
		- it does not need to tell the server about this because 




this will lay out some key points that should apply to loading mostly, but basically server sync in general.

- initializer thread

- server startup: reads from yaml?? note, values with [] are optional as the [] specifies a default value.
	- worldname <String>
	- port <int> [8405]
	- debug <bool> [false]
	- create <dict> [load world]
		- seed <String|long> [random long]
		- overwrite <bool>


- starts with connection inside kyro server thread
	- thread map is only accessed through connect and disconnect methods, which are only called in the server update thread. So no syncronization is needed there.

- about below: most stuff is in the main thread so what do I need to take out of it?

- once server thread is started for a connection, it handles packets recieved
	- login packet is first
		- server should contain all info to check if the player is allowed to join, i.e. player list
		- world does not treat players in a special way EXCEPT to load levels... or... should it...? maybe server can? What causes a level to load?
	- once player is created, a request is made to load a level async; once loaded, the given player is added to the level.
		- entity additions are update thread only
		- the world has an entity addition(/movement/removal) queue, which is run through at the end of each frame in the update thread
		- because all updates will be done in the world update thread, and changes stored in a queue, entity fetches don't need to be synchronized
	- the call to load a level adds the level request, and player, to a queue for that level cache's thread.
		- levels are added to / removed from the world's level list only by the associated cache thread
		- the cache thread stores a linked list of Map entries of players to booleans
		- for each player entry...
			- if the bool is true (meaning load), then the world is asked if the level is already loaded
				- if not loaded, then a level is created, and the level is sync added to the world's level list.
			- the player is then added to the world's entity queue now that the level is loaded.
	- as for interaction between level loading and entity updates...
		- the set of loaded levels, and entity updates, share the same update queue
			- each entry in the queue is simply an action
			- the actions are added by world methods such as loadLevel, unloadLevel, setEntityLevel, and removeEntityLevel.
		- the world fetches the current levels at the start of each frame, and uses this list to update the levels
		- after all levels from the list are updated, the levels are re-fetched syncronized with getting a snapshot of the entity queue
		- this allows level additions followed by entity queue additions during update to

- levels will actually be the object that store the map from level to entities; they'll just have it.
	- adding an entity to a level will be done through the ServerWorld's public setEntityLevel method, but that will actually call package-private methods in the Level class which add an entity to the set.
	- the entity to level map will be kept in the world, as before.

- since the world will update server players like any other entity, the ServerPlayer class will handle packets during this update method. The ServerPlayer will handle these packets:
	- interact request
	- movement request
	- 


to mitigate save time when unneeded, level will have a modification flag. Or, more specifically, the level caches will.
	If a world is out of date, it will be recached for the current version, making it up to date and setting the flag.
	When a save request is made, and executed, all loaded levels will be cached, setting those flags as well.
	Finally, all flagged caches will be saved to file.
	The cache will save the world in a different thread per cache; each level cache need only sync on itself, when writing to file, when loading a level, and when caching the level.
		Each cache thread is responsible for writing a level to file, and loading the cache into a level.
		The main world update thread will save the level to the cache, synced ofc. 





Let's go over thread roles, to help clear things up.

- Server Update Thread
	- exclusive roles
		- calls update on levels, which call update on entities and update tiles
		- adds levels to the loaded level map
	- shared roles
		- 

- level cache threads
	- exclusive roles
		- writes cached data to file
	- shared roles
		- 

- game server main thread
	- exclusive roles
		- receive client packets and delegate to client threads
		- manage incoming connections
		- manage client disconnects
		- 
	- shared roles
		- 

- server client threads
	- exclusive roles
		- handle packets from client
	- shared roles
		- 

