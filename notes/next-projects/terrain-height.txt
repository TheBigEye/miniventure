MISC
- some tiles can be ramp-like, and bridge between tiles with different height levels (these should prob only bridge a one-layer difference) <-- <<this idea is fishy>>

- mountains have many layers of rock; the top-most rock layer of any tile on the mountain will have dirt on it, maybe grass
- the rock will still be visible on the edges


LAYERS/CRUST
- distinction between tile layers is at times unclear; tiles from the layer below may be interacted with.
- at the bottom of all tile stacks, instead of hole, use crust
	- crust is neither walkable nor breakable
	- on top of crust is compressed/packed dirt
		- it takes vertical space
		- a couple hits to remove


BREAKABILITY
sometimes the game will not allow you to break certain blocks that are normally breakable.
- a message or icon will appear in these situations to let you know somewhat what the problem is
- examples:
	- you are trying to break the tile you're standing on (message appears: "I'll fall!" or icon of boots with red circle cross over them)
	- trying to break a tile that is supporting tiletypes above it, and those tiletypes don't have support from adjacent tiles (message: "Unstable!" or icon of badly stacked blocks with motion lines)
	- trying to break / interact with the ground tile under a vertical tile (message: "Can't reach!" or icon of two stacked blocks with a cross through the bottom block)


PROPERTIES
separate tiletype properties:
- walkable / or custom collision bounds (common)

- vertical space / height (common)
	- vertical tiletype sprites are a little more than 32 pixels tall; they have a front-face that stands them up a bit
	- may have to be faded (ground tiles: renderer doesn't worry about fading or draw order)
		- all tiletypes existing above the player's current height, that obstruct tiles above them ("forward" of them technically) should be faded. That way, paths behind higher tiles are visible, but solid areas without any rendering behind them are not rendered.
			- when switching layers, the new layer should fade in gradually in accordance to the entity's z coordinate.
			- Note: caves will not be an issue because they have solid tiles above them. See section on caves below for more cave details
	- ground tiles have a different attack key than tiles with height
		- using the ground-tile key on a tile with height doesn't work (you have to remove the height tile first)
		- ground tiles are considered to be any tile with the same height level as the one you're standing on

- walkable on top / top collision bounds (common)
	- if vertical space is used, then you can't fall through the tile. Collision bounds determine walkability.
	- if no vertical space used, tile can be fallen through; if top collision bounds exists, it is respected, and objects only fall through the tile if they can fit around the collision bounds, AND the tile below is walkable, AND there is only a one-layer difference

- render occlusion (client); does this tiletype have a fully opaque sprite? If so, no tiles underneath it need to / should be rendered.

- light occlusion (client); does this tiletype block light from passing through?
	- all object lighting will be subject to occlusion; sunlight is the only exception, however attempts may be made to have light shadows

- update manager (server)
- destruction manager (server)
- transition manager (server)
- light radius (client)
- swim animation (client) - edit
- transitions (client)


CAVES
- When entering a cave, the structure above the cave will be faded
- This will leave all tiles at the height of the cave renderable
	- whether they are actually rendered (aka are visible) depends on the lighting
	- As stated above, light will be blocked by light-blocking tiletypes


DOOR FRAMES
note about sprite rendering with door frames:
the problem with previous attempts to ensure correct rendering with sprites around door frames is that sprite vertical height (not pixels necessarily, but world height...which may be pixels) was never taken into account for collision detection. If the sprite is too tall, aka tall enough where it touches the top of the door frame, it shouldn't be able to go through the door.
Now, an easier and arguably better solution (in my case at least) is probably to just not make the sprites of door-traversing entities too tall for doors.
Another solution, though, is to not use door frames, and instead just have a hinged door that swings on a hinge with two different collision boxes, one for the closed door and one for the open door.


COORDINATES
with a height map, the rendering coordinate system splits from the position coordinate system.
- Rendering has only x and y, but position has x, y, and z.
- the z coordinate is a float too
- 


IMPL PLAN
- first is making the system for tracking vertical tiletypes and raising them up
- prob: player position when traversing layers
	
	maybe ramp tile edges aren't such a good idea for a sandbox game..?
	let's do ramp tiles instead. These can only ramp in one direction.	
	- 
	- for ramp tiles, the lower tile overlaps the "front-face" of the upper tile
	- any distance covered perpendicular to the front-face, while the center of an entity is within the bounds of the front-face, is counted towards z instead of y. one z unit is then defined (for that direction) as the length of the front-face in the dimension perpendicular to the axis of the face.
	- in terms of collision, and more for the purposes of high speed movement (speeds that technically shouldn't be allowed unless in debug mode, but I'll implement it for that and in case of some weird lag glitches or something), if a movement results in the sprite being on a tile with a different stack height than the starting tile...
		- ...and is making an illegal collision, then the movement is re-tried with the tiletype at the same stack height as the entity.
		- ...and is not making any illegal collisions, then the movement on the axis perpendicular to the face axis (for a wall along the y axis, it's the x movement, and vice versa) is lessened by the perpendicular face length times the number of levels of difference there are between the original and new positions. Then the level count is added to the z coordinate.
			- note that in this approach, the entity is effectively scaling a cliff which is the side of the tile.
			- This should work even if the ending position is overlapping a ramped face; simply compute the new z position of the center of the sprite at the new location, and use that as opposed to a simple integer.
			- note that, when moving horizontally, this will move the entity up (or down) on screen (but the positional y coordinate will remain unchanged). Upward movement will not show any anomalies. Downward movement up a ramp will...
			 	- ...make the entity move downward on screen slower than normal walk speed, assuming that the back end of the sprite is at least partly visible. Or, even with my proposed rendering system with overlap, if the 
			 	- ...make the entity move upward on screen if the tile face is not at all visible, and the tile renders over the tile above it (in the y dir not z). In this case, the entity would go down on screen to the bottom of the tile with the lower z but greater y, and then it would go up the screen, increasing its positional z only (positional y is constant) until it matched the z of the upper tile.
